package org.mobicents.functional.concurrent;


import org.mobicents.functional.Attempt;

import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Supplier;

/**
 *
    `Task` is a trampolined computation producing an `A` that may
    include asynchronous steps. Arbitrary monadic expressions involving
    `map` and `flatMap` are guaranteed to use constant stack space.
    In addition, using `Task.async`, one may construct a `Task` from
    callback-based APIs. This makes `Task` useful as a concurrency primitive
    and as a control structure for wrapping callback-based APIs with a more
    straightforward, monadic API.

    Task is also exception-safe. Any exceptions raised during processing may
    be accessed via the `attempt` method, which converts a `Task<<A>>` to a
    `Task<Attempt<A>>`.

    Note that Task oes not represent a _running_ computation. Instead, we
    reintroduce concurrency _explicitly_ using the `Task.start` function.
    This simplifies our implementation and makes code easier to reason about,
    since the order of effects and the points of allowed concurrency are made
    fully explicit and do not depend on  java  evaluation order.

    This code is based on Task type used in fs2._ scala library. (https://github.com/functional-streams-for-scala/fs2)

*/
public class Task<A> {
    Future<Attempt<A>> get;

    Task( Future<Attempt<A>> get) { this.get = get; }


    public<B> Task<B> flatMap(Function<A,Task<B>> f) {
        return(new Task( get.flatMap( attempt ->
          attempt.fold(
                  a ->  Attempt.attempt(() -> f.apply(a)).fold(
                          b -> Future.now(Attempt.success(b))
                          , rsn -> Future.now(Attempt.failed(rsn))
                  )
                  , rsn -> Future.now(Attempt.failed(rsn))
          )
        )));
    }

    public<B> Task<B> map( Function<A,B> f) {
       return(new Task( get.map ( attempt -> attempt.map(f) )));
    }

    /** 'Catches' exceptions in the given task and returns them as values of Attempt. */
    public Task<Attempt<A>> attempt() {
        return(new Task( get.map( attempt -> Attempt.success(attempt) ) ));
    }

    /** Returns a task that performs all evaluation asynchronously. That means it forks evaluation to provided Strategy */
    public Task<A> async(Strategy s){
        return(Task.start(s,this).flatMap( Function.identity() ));
    }

    /**
     * Run this `Task` and block until its result is available. This will
     * throw any exceptions generated by the `Task`. To return exceptions
     * in an `Attempt`, use `attempt().unsafeRun()`.
     */
    public A unsafeRun() throws Throwable {
        return(get.run().get());
    }

    /**
     * Run this computation to obtain either a result or an exception, then
     * invoke the given callback. Any pure, non-asynchronous computation at the
     * head of this `Task` will be forced in the calling thread. At the first
     * `Async` encountered, control is transferred to whatever thread backs the
     * `Async` and this function returns immediately.
     */
    public void unsafeRunAsync(Consumer<Attempt<A>> f) {
        get.runAsync(f);
    }

    /** A `Task` which fails with the given `Throwable`. */
    static<A> Task<A> fail(Throwable err) { return(new Task(Future.now(Attempt.failed(err)))); }

    /** Convert a strict value to a `Task`. Also see `delay`. */
    static<A> Task<A> now(A a) { return(new Task(Future.now(Attempt.success(a)))); }

    /**
     * Promote a non-strict value to a `Task`, catching exceptions in
     * the process. Note that since `Task` is unmemoized, this will
     * recompute `a` each time it is sequenced into a larger computation.
     */
    static<A> Task<A> delay(Supplier<A> f) { return(suspend(() -> now(f.get())));  }


    /**
     * Produce a Task that suspends its evaluation until it is run
     */
    static<A> Task<A> suspend(Supplier<Task<A>> thunk) {
        return(new Task(Future.suspend( () ->
            Attempt.attempt(thunk).map(t -> t.get).fold(ft -> ft , err -> Future.now(((Attempt<A>)Attempt.failed(err))))
        )));
    }

    /**
     * Create a `Task` from an asynchronous computation, which takes the form
     * of a function with which we can register a callback. This can be used
     * to translate from a callback-based API to a straightforward monadic
     * version. The callback is run using the strategy `S`.
     */
    static<A> Task<A> async(Strategy s, Consumer<Consumer<Attempt<A>>> register) {
       return(new Task(Future.async(s, cb ->
          register.accept(aAttempt -> {
              try { s.run(() -> { cb.accept(aAttempt) ; return null; }) ; }
              catch (Throwable rsn ) { cb.accept(Attempt.failed(rsn)) ; }
          })
       )));
    }

    /**
     * Given `t: Task[A]`, `start(t)` returns a `Task[Task[A]]`. After `flatMap`-ing
     * into the outer task, `t` will be running in the background, and the inner task
     * is conceptually a future which can be forced at any point via `flatMap`.

     * For example (scala code):

     * {{{
     for {
     f <- Task.start { expensiveTask1 }
     // at this point, `expensive1` is evaluating in background
     g <- Task.start { expensiveTask2 }
     // now both `expensiveTask2` and `expensiveTask1` are running
     result1 <- f
     // we have forced `f`, so now only `expensiveTask2` may be running
     result2 <- g
     // we have forced `g`, so now nothing is running and we have both results
     } yield (result1 + result2)
     }}}
     */
    static<A> Task<Task<A>> start(Strategy s, Task<A> t) {
        throw new RuntimeException("todo") ; // todo
     }

}
