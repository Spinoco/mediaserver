package org.mobicents.media.server.impl.dsp.audio.opus;

import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.PointerType;
import com.sun.jna.ptr.FloatByReference;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;
import com.sun.jna.ptr.ShortByReference;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;
import java.nio.ShortBuffer;
/**
 * JNA Wrapper for library <b>opus</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface OpusLibrary extends Library {
    public static final String JNA_LIBRARY_NAME = "opus";
    public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(OpusLibrary.JNA_LIBRARY_NAME);
    public static final OpusLibrary INSTANCE = (OpusLibrary)Native.loadLibrary(OpusLibrary.JNA_LIBRARY_NAME, OpusLibrary.class);
    public static final int OPUS_OK = (int)0;
    public static final int OPUS_BAD_ARG = (int)-1;
    public static final int OPUS_BUFFER_TOO_SMALL = (int)-2;
    public static final int OPUS_INTERNAL_ERROR = (int)-3;
    public static final int OPUS_INVALID_PACKET = (int)-4;
    public static final int OPUS_UNIMPLEMENTED = (int)-5;
    public static final int OPUS_INVALID_STATE = (int)-6;
    public static final int OPUS_ALLOC_FAIL = (int)-7;
    public static final int OPUS_SET_APPLICATION_REQUEST = (int)4000;
    public static final int OPUS_GET_APPLICATION_REQUEST = (int)4001;
    public static final int OPUS_SET_BITRATE_REQUEST = (int)4002;
    public static final int OPUS_GET_BITRATE_REQUEST = (int)4003;
    public static final int OPUS_SET_MAX_BANDWIDTH_REQUEST = (int)4004;
    public static final int OPUS_GET_MAX_BANDWIDTH_REQUEST = (int)4005;
    public static final int OPUS_SET_VBR_REQUEST = (int)4006;
    public static final int OPUS_GET_VBR_REQUEST = (int)4007;
    public static final int OPUS_SET_BANDWIDTH_REQUEST = (int)4008;
    public static final int OPUS_GET_BANDWIDTH_REQUEST = (int)4009;
    public static final int OPUS_SET_COMPLEXITY_REQUEST = (int)4010;
    public static final int OPUS_GET_COMPLEXITY_REQUEST = (int)4011;
    public static final int OPUS_SET_INBAND_FEC_REQUEST = (int)4012;
    public static final int OPUS_GET_INBAND_FEC_REQUEST = (int)4013;
    public static final int OPUS_SET_PACKET_LOSS_PERC_REQUEST = (int)4014;
    public static final int OPUS_GET_PACKET_LOSS_PERC_REQUEST = (int)4015;
    public static final int OPUS_SET_DTX_REQUEST = (int)4016;
    public static final int OPUS_GET_DTX_REQUEST = (int)4017;
    public static final int OPUS_SET_VBR_CONSTRAINT_REQUEST = (int)4020;
    public static final int OPUS_GET_VBR_CONSTRAINT_REQUEST = (int)4021;
    public static final int OPUS_SET_FORCE_CHANNELS_REQUEST = (int)4022;
    public static final int OPUS_GET_FORCE_CHANNELS_REQUEST = (int)4023;
    public static final int OPUS_SET_SIGNAL_REQUEST = (int)4024;
    public static final int OPUS_GET_SIGNAL_REQUEST = (int)4025;
    public static final int OPUS_GET_LOOKAHEAD_REQUEST = (int)4027;
    public static final int OPUS_GET_SAMPLE_RATE_REQUEST = (int)4029;
    public static final int OPUS_GET_FINAL_RANGE_REQUEST = (int)4031;
    public static final int OPUS_GET_PITCH_REQUEST = (int)4033;
    public static final int OPUS_SET_GAIN_REQUEST = (int)4034;
    public static final int OPUS_GET_GAIN_REQUEST = (int)4045;
    public static final int OPUS_SET_LSB_DEPTH_REQUEST = (int)4036;
    public static final int OPUS_GET_LSB_DEPTH_REQUEST = (int)4037;
    public static final int OPUS_GET_LAST_PACKET_DURATION_REQUEST = (int)4039;
    public static final int OPUS_SET_EXPERT_FRAME_DURATION_REQUEST = (int)4040;
    public static final int OPUS_GET_EXPERT_FRAME_DURATION_REQUEST = (int)4041;
    public static final int OPUS_SET_PREDICTION_DISABLED_REQUEST = (int)4042;
    public static final int OPUS_GET_PREDICTION_DISABLED_REQUEST = (int)4043;
    public static final int OPUS_AUTO = (int)-1000;
    public static final int OPUS_BITRATE_MAX = (int)-1;
    public static final int OPUS_APPLICATION_VOIP = (int)2048;
    public static final int OPUS_APPLICATION_AUDIO = (int)2049;
    public static final int OPUS_APPLICATION_RESTRICTED_LOWDELAY = (int)2051;
    public static final int OPUS_SIGNAL_VOICE = (int)3001;
    public static final int OPUS_SIGNAL_MUSIC = (int)3002;
    public static final int OPUS_BANDWIDTH_NARROWBAND = (int)1101;
    public static final int OPUS_BANDWIDTH_MEDIUMBAND = (int)1102;
    public static final int OPUS_BANDWIDTH_WIDEBAND = (int)1103;
    public static final int OPUS_BANDWIDTH_SUPERWIDEBAND = (int)1104;
    public static final int OPUS_BANDWIDTH_FULLBAND = (int)1105;
    public static final int OPUS_FRAMESIZE_ARG = (int)5000;
    public static final int OPUS_FRAMESIZE_2_5_MS = (int)5001;
    public static final int OPUS_FRAMESIZE_5_MS = (int)5002;
    public static final int OPUS_FRAMESIZE_10_MS = (int)5003;
    public static final int OPUS_FRAMESIZE_20_MS = (int)5004;
    public static final int OPUS_FRAMESIZE_40_MS = (int)5005;
    public static final int OPUS_FRAMESIZE_60_MS = (int)5006;
    public static final int OPUS_RESET_STATE = (int)4028;
    /**
     * Converts an opus error code into a human readable string.<br>
     * @param[in] error <tt>int</tt>: Error number<br>
     * @returns Error string<br>
     * Original signature : <code>char* opus_strerror(int)</code><br>
     * <i>native declaration : line 935</i>
     */
    Pointer opus_strerror(int error);
    /**
     * Gets the libopus version string.<br>
     * Applications may look for the substring "-fixed" in the version string to<br>
     * determine whether they have a fixed-point or floating-point build at<br>
     * runtime.<br>
     * @returns Version string<br>
     * Original signature : <code>char* opus_get_version_string()</code><br>
     * <i>native declaration : line 945</i>
     */
    Pointer opus_get_version_string();
    /**
     * Gets the size of an <code>OpusEncoder</code> structure.<br>
     * @param[in] channels <tt>int</tt>: Number of channels.<br>
     *                                   This must be 1 or 2.<br>
     * @returns The size in bytes.<br>
     * Original signature : <code>int opus_encoder_get_size(int)</code><br>
     * <i>native declaration : line 1087</i>
     */
    int opus_encoder_get_size(int channels);
    /**
     * Allocates and initializes an encoder state.<br>
     * There are three coding modes:<br>
     * @ref OPUS_APPLICATION_VOIP gives best quality at a given bitrate for voice<br>
     *    signals. It enhances the  input signal by high-pass filtering and<br>
     *    emphasizing formants and harmonics. Optionally  it includes in-band<br>
     *    forward error correction to protect against packet loss. Use this<br>
     *    mode for typical VoIP applications. Because of the enhancement,<br>
     *    even at high bitrates the output may sound different from the input.<br>
     * @ref OPUS_APPLICATION_AUDIO gives best quality at a given bitrate for most<br>
     *    non-voice signals like music. Use this mode for music and mixed<br>
     *    (music/voice) content, broadcast, and applications requiring less<br>
     *    than 15 ms of coding delay.<br>
     * @ref OPUS_APPLICATION_RESTRICTED_LOWDELAY configures low-delay mode that<br>
     *    disables the speech-optimized mode in exchange for slightly reduced delay.<br>
     *    This mode can only be set on an newly initialized or freshly reset encoder<br>
     *    because it changes the codec delay.<br>
     * This is useful when the caller knows that the speech-optimized modes will not be needed (use with caution).<br>
     * @param [in] Fs <tt>opus_int32</tt>: Sampling rate of input signal (Hz)<br>
     *                                     This must be one of 8000, 12000, 16000,<br>
     *                                     24000, or 48000.<br>
     * @param [in] channels <tt>int</tt>: Number of channels (1 or 2) in input signal<br>
     * @param [in] application <tt>int</tt>: Coding mode (@ref OPUS_APPLICATION_VOIP/@ref OPUS_APPLICATION_AUDIO/@ref OPUS_APPLICATION_RESTRICTED_LOWDELAY)<br>
     * @param [out] error <tt>int*</tt>: @ref opus_errorcodes<br>
     * @note Regardless of the sampling rate and number channels selected, the Opus encoder<br>
     * can switch to a lower audio bandwidth or number of channels if the bitrate<br>
     * selected is too low. This also means that it is safe to always use 48 kHz stereo input<br>
     * and let the encoder optimize the encoding.<br>
     * Original signature : <code>OpusEncoder* opus_encoder_create(opus_int32, int, int, int*)</code><br>
     * <i>native declaration : line 1124</i><br>
     * @deprecated use the safer methods {@link #opus_encoder_create(int, int, int, java.nio.IntBuffer)} and {@link #opus_encoder_create(int, int, int, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    PointerByReference opus_encoder_create(int Fs, int channels, int application, IntByReference error);
    /**
     * Allocates and initializes an encoder state.<br>
     * There are three coding modes:<br>
     * @ref OPUS_APPLICATION_VOIP gives best quality at a given bitrate for voice<br>
     *    signals. It enhances the  input signal by high-pass filtering and<br>
     *    emphasizing formants and harmonics. Optionally  it includes in-band<br>
     *    forward error correction to protect against packet loss. Use this<br>
     *    mode for typical VoIP applications. Because of the enhancement,<br>
     *    even at high bitrates the output may sound different from the input.<br>
     * @ref OPUS_APPLICATION_AUDIO gives best quality at a given bitrate for most<br>
     *    non-voice signals like music. Use this mode for music and mixed<br>
     *    (music/voice) content, broadcast, and applications requiring less<br>
     *    than 15 ms of coding delay.<br>
     * @ref OPUS_APPLICATION_RESTRICTED_LOWDELAY configures low-delay mode that<br>
     *    disables the speech-optimized mode in exchange for slightly reduced delay.<br>
     *    This mode can only be set on an newly initialized or freshly reset encoder<br>
     *    because it changes the codec delay.<br>
     * This is useful when the caller knows that the speech-optimized modes will not be needed (use with caution).<br>
     * @param [in] Fs <tt>opus_int32</tt>: Sampling rate of input signal (Hz)<br>
     *                                     This must be one of 8000, 12000, 16000,<br>
     *                                     24000, or 48000.<br>
     * @param [in] channels <tt>int</tt>: Number of channels (1 or 2) in input signal<br>
     * @param [in] application <tt>int</tt>: Coding mode (@ref OPUS_APPLICATION_VOIP/@ref OPUS_APPLICATION_AUDIO/@ref OPUS_APPLICATION_RESTRICTED_LOWDELAY)<br>
     * @param [out] error <tt>int*</tt>: @ref opus_errorcodes<br>
     * @note Regardless of the sampling rate and number channels selected, the Opus encoder<br>
     * can switch to a lower audio bandwidth or number of channels if the bitrate<br>
     * selected is too low. This also means that it is safe to always use 48 kHz stereo input<br>
     * and let the encoder optimize the encoding.<br>
     * Original signature : <code>OpusEncoder* opus_encoder_create(opus_int32, int, int, int*)</code><br>
     * <i>native declaration : line 1124</i>
     */
    PointerByReference opus_encoder_create(int Fs, int channels, int application, IntBuffer error);
    /**
     * Initializes a previously allocated encoder state<br>
     * The memory pointed to by st must be at least the size returned by opus_encoder_get_size().<br>
     * This is intended for applications which use their own allocator instead of malloc.<br>
     * @see opus_encoder_create(),opus_encoder_get_size()<br>
     * To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.<br>
     * @param [in] st <tt>OpusEncoder*</tt>: Encoder state<br>
     * @param [in] Fs <tt>opus_int32</tt>: Sampling rate of input signal (Hz)<br>
     *                                      This must be one of 8000, 12000, 16000,<br>
     *                                      24000, or 48000.<br>
     * @param [in] channels <tt>int</tt>: Number of channels (1 or 2) in input signal<br>
     * @param [in] application <tt>int</tt>: Coding mode (OPUS_APPLICATION_VOIP/OPUS_APPLICATION_AUDIO/OPUS_APPLICATION_RESTRICTED_LOWDELAY)<br>
     * @retval #OPUS_OK Success or @ref opus_errorcodes<br>
     * Original signature : <code>int opus_encoder_init(OpusEncoder*, opus_int32, int, int)</code><br>
     * <i>native declaration : line 1144</i><br>
     * @deprecated use the safer method {@link #opus_encoder_init(com.sun.jna.ptr.PointerByReference, int, int, int)} instead
     */
    @Deprecated
    int opus_encoder_init(Pointer st, int Fs, int channels, int application);
    /**
     * Initializes a previously allocated encoder state<br>
     * The memory pointed to by st must be at least the size returned by opus_encoder_get_size().<br>
     * This is intended for applications which use their own allocator instead of malloc.<br>
     * @see opus_encoder_create(),opus_encoder_get_size()<br>
     * To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.<br>
     * @param [in] st <tt>OpusEncoder*</tt>: Encoder state<br>
     * @param [in] Fs <tt>opus_int32</tt>: Sampling rate of input signal (Hz)<br>
     *                                      This must be one of 8000, 12000, 16000,<br>
     *                                      24000, or 48000.<br>
     * @param [in] channels <tt>int</tt>: Number of channels (1 or 2) in input signal<br>
     * @param [in] application <tt>int</tt>: Coding mode (OPUS_APPLICATION_VOIP/OPUS_APPLICATION_AUDIO/OPUS_APPLICATION_RESTRICTED_LOWDELAY)<br>
     * @retval #OPUS_OK Success or @ref opus_errorcodes<br>
     * Original signature : <code>int opus_encoder_init(OpusEncoder*, opus_int32, int, int)</code><br>
     * <i>native declaration : line 1144</i>
     */
    int opus_encoder_init(PointerByReference st, int Fs, int channels, int application);
    /**
     * Encodes an Opus frame.<br>
     * @param [in] st <tt>OpusEncoder*</tt>: Encoder state<br>
     * @param [in] pcm <tt>opus_int16*</tt>: Input signal (interleaved if 2 channels). length is frame_size*channels*sizeof(opus_int16)<br>
     * @param [in] frame_size <tt>int</tt>: Number of samples per channel in the<br>
     *                                      input signal.<br>
     *                                      This must be an Opus frame size for<br>
     *                                      the encoder's sampling rate.<br>
     *                                      For example, at 48 kHz the permitted<br>
     *                                      values are 120, 240, 480, 960, 1920,<br>
     *                                      and 2880.<br>
     *                                      Passing in a duration of less than<br>
     *                                      10 ms (480 samples at 48 kHz) will<br>
     *                                      prevent the encoder from using the LPC<br>
     *                                      or hybrid modes.<br>
     * @param [out] data <tt>unsigned char*</tt>: Output payload.<br>
     *                                            This must contain storage for at<br>
     *                                            least \a max_data_bytes.<br>
     * @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated<br>
     *                                                 memory for the output<br>
     *                                                 payload. This may be<br>
     *                                                 used to impose an upper limit on<br>
     *                                                 the instant bitrate, but should<br>
     *                                                 not be used as the only bitrate<br>
     *                                                 control. Use #OPUS_SET_BITRATE to<br>
     *                                                 control the bitrate.<br>
     * @returns The length of the encoded packet (in bytes) on success or a<br>
     *          negative error code (see @ref opus_errorcodes) on failure.<br>
     * Original signature : <code>opus_int32 opus_encode(OpusEncoder*, const opus_int16*, int, unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1179</i><br>
     * @deprecated use the safer methods {@link #opus_encode(com.sun.jna.ptr.PointerByReference, java.nio.ShortBuffer, int, java.nio.ByteBuffer, int)} and {@link #opus_encode(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.ShortByReference, int, com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    int opus_encode(Pointer st, ShortByReference pcm, int frame_size, Pointer data, int max_data_bytes);
    /**
     * Encodes an Opus frame.<br>
     * @param [in] st <tt>OpusEncoder*</tt>: Encoder state<br>
     * @param [in] pcm <tt>opus_int16*</tt>: Input signal (interleaved if 2 channels). length is frame_size*channels*sizeof(opus_int16)<br>
     * @param [in] frame_size <tt>int</tt>: Number of samples per channel in the<br>
     *                                      input signal.<br>
     *                                      This must be an Opus frame size for<br>
     *                                      the encoder's sampling rate.<br>
     *                                      For example, at 48 kHz the permitted<br>
     *                                      values are 120, 240, 480, 960, 1920,<br>
     *                                      and 2880.<br>
     *                                      Passing in a duration of less than<br>
     *                                      10 ms (480 samples at 48 kHz) will<br>
     *                                      prevent the encoder from using the LPC<br>
     *                                      or hybrid modes.<br>
     * @param [out] data <tt>unsigned char*</tt>: Output payload.<br>
     *                                            This must contain storage for at<br>
     *                                            least \a max_data_bytes.<br>
     * @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated<br>
     *                                                 memory for the output<br>
     *                                                 payload. This may be<br>
     *                                                 used to impose an upper limit on<br>
     *                                                 the instant bitrate, but should<br>
     *                                                 not be used as the only bitrate<br>
     *                                                 control. Use #OPUS_SET_BITRATE to<br>
     *                                                 control the bitrate.<br>
     * @returns The length of the encoded packet (in bytes) on success or a<br>
     *          negative error code (see @ref opus_errorcodes) on failure.<br>
     * Original signature : <code>opus_int32 opus_encode(OpusEncoder*, const opus_int16*, int, unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1179</i>
     */
    int opus_encode(PointerByReference st, ShortBuffer pcm, int frame_size, ByteBuffer data, int max_data_bytes);
    /**
     * Encodes an Opus frame.<br>
     * @param [in] st <tt>OpusEncoder*</tt>: Encoder state<br>
     * @param [in] pcm <tt>opus_int16*</tt>: Input signal (interleaved if 2 channels). length is frame_size*channels*sizeof(opus_int16)<br>
     * @param [in] frame_size <tt>int</tt>: Number of samples per channel in the<br>
     *                                      input signal.<br>
     *                                      This must be an Opus frame size for<br>
     *                                      the encoder's sampling rate.<br>
     *                                      For example, at 48 kHz the permitted<br>
     *                                      values are 120, 240, 480, 960, 1920,<br>
     *                                      and 2880.<br>
     *                                      Passing in a duration of less than<br>
     *                                      10 ms (480 samples at 48 kHz) will<br>
     *                                      prevent the encoder from using the LPC<br>
     *                                      or hybrid modes.<br>
     * @param [out] data <tt>unsigned char*</tt>: Output payload.<br>
     *                                            This must contain storage for at<br>
     *                                            least \a max_data_bytes.<br>
     * @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated<br>
     *                                                 memory for the output<br>
     *                                                 payload. This may be<br>
     *                                                 used to impose an upper limit on<br>
     *                                                 the instant bitrate, but should<br>
     *                                                 not be used as the only bitrate<br>
     *                                                 control. Use #OPUS_SET_BITRATE to<br>
     *                                                 control the bitrate.<br>
     * @returns The length of the encoded packet (in bytes) on success or a<br>
     *          negative error code (see @ref opus_errorcodes) on failure.<br>
     * Original signature : <code>opus_int32 opus_encode(OpusEncoder*, const opus_int16*, int, unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1179</i>
     */
    int opus_encode(PointerByReference st, ShortByReference pcm, int frame_size, Pointer data, int max_data_bytes);
    /**
     * Encodes an Opus frame from floating point input.<br>
     * @param [in] st <tt>OpusEncoder*</tt>: Encoder state<br>
     * @param [in] pcm <tt>float*</tt>: Input in float format (interleaved if 2 channels), with a normal range of +/-1.0.<br>
     *          Samples with a range beyond +/-1.0 are supported but will<br>
     *          be clipped by decoders using the integer API and should<br>
     *          only be used if it is known that the far end supports<br>
     *          extended dynamic range.<br>
     *          length is frame_size*channels*sizeof(float)<br>
     * @param [in] frame_size <tt>int</tt>: Number of samples per channel in the<br>
     *                                      input signal.<br>
     *                                      This must be an Opus frame size for<br>
     *                                      the encoder's sampling rate.<br>
     *                                      For example, at 48 kHz the permitted<br>
     *                                      values are 120, 240, 480, 960, 1920,<br>
     *                                      and 2880.<br>
     *                                      Passing in a duration of less than<br>
     *                                      10 ms (480 samples at 48 kHz) will<br>
     *                                      prevent the encoder from using the LPC<br>
     *                                      or hybrid modes.<br>
     * @param [out] data <tt>unsigned char*</tt>: Output payload.<br>
     *                                            This must contain storage for at<br>
     *                                            least \a max_data_bytes.<br>
     * @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated<br>
     *                                                 memory for the output<br>
     *                                                 payload. This may be<br>
     *                                                 used to impose an upper limit on<br>
     *                                                 the instant bitrate, but should<br>
     *                                                 not be used as the only bitrate<br>
     *                                                 control. Use #OPUS_SET_BITRATE to<br>
     *                                                 control the bitrate.<br>
     * @returns The length of the encoded packet (in bytes) on success or a<br>
     *          negative error code (see @ref opus_errorcodes) on failure.<br>
     * Original signature : <code>opus_int32 opus_encode_float(OpusEncoder*, const float*, int, unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1220</i><br>
     * @deprecated use the safer methods {@link #opus_encode_float(com.sun.jna.ptr.PointerByReference, float[], int, java.nio.ByteBuffer, int)} and {@link #opus_encode_float(com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.FloatByReference, int, com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    int opus_encode_float(Pointer st, FloatByReference pcm, int frame_size, Pointer data, int max_data_bytes);
    /**
     * Encodes an Opus frame from floating point input.<br>
     * @param [in] st <tt>OpusEncoder*</tt>: Encoder state<br>
     * @param [in] pcm <tt>float*</tt>: Input in float format (interleaved if 2 channels), with a normal range of +/-1.0.<br>
     *          Samples with a range beyond +/-1.0 are supported but will<br>
     *          be clipped by decoders using the integer API and should<br>
     *          only be used if it is known that the far end supports<br>
     *          extended dynamic range.<br>
     *          length is frame_size*channels*sizeof(float)<br>
     * @param [in] frame_size <tt>int</tt>: Number of samples per channel in the<br>
     *                                      input signal.<br>
     *                                      This must be an Opus frame size for<br>
     *                                      the encoder's sampling rate.<br>
     *                                      For example, at 48 kHz the permitted<br>
     *                                      values are 120, 240, 480, 960, 1920,<br>
     *                                      and 2880.<br>
     *                                      Passing in a duration of less than<br>
     *                                      10 ms (480 samples at 48 kHz) will<br>
     *                                      prevent the encoder from using the LPC<br>
     *                                      or hybrid modes.<br>
     * @param [out] data <tt>unsigned char*</tt>: Output payload.<br>
     *                                            This must contain storage for at<br>
     *                                            least \a max_data_bytes.<br>
     * @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated<br>
     *                                                 memory for the output<br>
     *                                                 payload. This may be<br>
     *                                                 used to impose an upper limit on<br>
     *                                                 the instant bitrate, but should<br>
     *                                                 not be used as the only bitrate<br>
     *                                                 control. Use #OPUS_SET_BITRATE to<br>
     *                                                 control the bitrate.<br>
     * @returns The length of the encoded packet (in bytes) on success or a<br>
     *          negative error code (see @ref opus_errorcodes) on failure.<br>
     * Original signature : <code>opus_int32 opus_encode_float(OpusEncoder*, const float*, int, unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1220</i>
     */
    int opus_encode_float(PointerByReference st, float pcm[], int frame_size, ByteBuffer data, int max_data_bytes);
    /**
     * Encodes an Opus frame from floating point input.<br>
     * @param [in] st <tt>OpusEncoder*</tt>: Encoder state<br>
     * @param [in] pcm <tt>float*</tt>: Input in float format (interleaved if 2 channels), with a normal range of +/-1.0.<br>
     *          Samples with a range beyond +/-1.0 are supported but will<br>
     *          be clipped by decoders using the integer API and should<br>
     *          only be used if it is known that the far end supports<br>
     *          extended dynamic range.<br>
     *          length is frame_size*channels*sizeof(float)<br>
     * @param [in] frame_size <tt>int</tt>: Number of samples per channel in the<br>
     *                                      input signal.<br>
     *                                      This must be an Opus frame size for<br>
     *                                      the encoder's sampling rate.<br>
     *                                      For example, at 48 kHz the permitted<br>
     *                                      values are 120, 240, 480, 960, 1920,<br>
     *                                      and 2880.<br>
     *                                      Passing in a duration of less than<br>
     *                                      10 ms (480 samples at 48 kHz) will<br>
     *                                      prevent the encoder from using the LPC<br>
     *                                      or hybrid modes.<br>
     * @param [out] data <tt>unsigned char*</tt>: Output payload.<br>
     *                                            This must contain storage for at<br>
     *                                            least \a max_data_bytes.<br>
     * @param [in] max_data_bytes <tt>opus_int32</tt>: Size of the allocated<br>
     *                                                 memory for the output<br>
     *                                                 payload. This may be<br>
     *                                                 used to impose an upper limit on<br>
     *                                                 the instant bitrate, but should<br>
     *                                                 not be used as the only bitrate<br>
     *                                                 control. Use #OPUS_SET_BITRATE to<br>
     *                                                 control the bitrate.<br>
     * @returns The length of the encoded packet (in bytes) on success or a<br>
     *          negative error code (see @ref opus_errorcodes) on failure.<br>
     * Original signature : <code>opus_int32 opus_encode_float(OpusEncoder*, const float*, int, unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1220</i>
     */
    int opus_encode_float(PointerByReference st, FloatByReference pcm, int frame_size, Pointer data, int max_data_bytes);
    /**
     * Frees an <code>OpusEncoder</code> allocated by opus_encoder_create().<br>
     * @param[in] st <tt>OpusEncoder*</tt>: State to be freed.<br>
     * Original signature : <code>void opus_encoder_destroy(OpusEncoder*)</code><br>
     * <i>native declaration : line 1231</i><br>
     * @deprecated use the safer method {@link #opus_encoder_destroy(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    void opus_encoder_destroy(Pointer st);
    /**
     * Frees an <code>OpusEncoder</code> allocated by opus_encoder_create().<br>
     * @param[in] st <tt>OpusEncoder*</tt>: State to be freed.<br>
     * Original signature : <code>void opus_encoder_destroy(OpusEncoder*)</code><br>
     * <i>native declaration : line 1231</i>
     */
    void opus_encoder_destroy(PointerByReference st);
    /**
     * Perform a CTL function on an Opus encoder.<br>
     * Generally the request and subsequent arguments are generated<br>
     * by a convenience macro.<br>
     * @param st <tt>OpusEncoder*</tt>: Encoder state.<br>
     * @param request This and all remaining parameters should be replaced by one<br>
     *                of the convenience macros in @ref opus_genericctls or<br>
     *                @ref opus_encoderctls.<br>
     * @see opus_genericctls<br>
     * @see opus_encoderctls<br>
     * Original signature : <code>int opus_encoder_ctl(OpusEncoder*, int, null)</code><br>
     * <i>native declaration : line 1244</i><br>
     * @deprecated use the safer method {@link #opus_encoder_ctl(com.sun.jna.ptr.PointerByReference, int, java.lang.Object)} instead
     */
    @Deprecated
    int opus_encoder_ctl(Pointer st, int request, Object... varArgs1);
    /**
     * Perform a CTL function on an Opus encoder.<br>
     * Generally the request and subsequent arguments are generated<br>
     * by a convenience macro.<br>
     * @param st <tt>OpusEncoder*</tt>: Encoder state.<br>
     * @param request This and all remaining parameters should be replaced by one<br>
     *                of the convenience macros in @ref opus_genericctls or<br>
     *                @ref opus_encoderctls.<br>
     * @see opus_genericctls<br>
     * @see opus_encoderctls<br>
     * Original signature : <code>int opus_encoder_ctl(OpusEncoder*, int, null)</code><br>
     * <i>native declaration : line 1244</i>
     */
    int opus_encoder_ctl(PointerByReference st, int request, Object... varArgs1);
    /**
     * Gets the size of an <code>OpusDecoder</code> structure.<br>
     * @param [in] channels <tt>int</tt>: Number of channels.<br>
     *                                    This must be 1 or 2.<br>
     * @returns The size in bytes.<br>
     * Original signature : <code>int opus_decoder_get_size(int)</code><br>
     * <i>native declaration : line 1322</i>
     */
    int opus_decoder_get_size(int channels);
    /**
     * Allocates and initializes a decoder state.<br>
     * @param [in] Fs <tt>opus_int32</tt>: Sample rate to decode at (Hz).<br>
     *                                     This must be one of 8000, 12000, 16000,<br>
     *                                     24000, or 48000.<br>
     * @param [in] channels <tt>int</tt>: Number of channels (1 or 2) to decode<br>
     * @param [out] error <tt>int*</tt>: #OPUS_OK Success or @ref opus_errorcodes<br>
     * Internally Opus stores data at 48000 Hz, so that should be the default<br>
     * value for Fs. However, the decoder can efficiently decode to buffers<br>
     * at 8, 12, 16, and 24 kHz so if for some reason the caller cannot use<br>
     * data at the full sample rate, or knows the compressed data doesn't<br>
     * use the full frequency range, it can request decoding at a reduced<br>
     * rate. Likewise, the decoder is capable of filling in either mono or<br>
     * interleaved stereo pcm buffers, at the caller's request.<br>
     * Original signature : <code>OpusDecoder* opus_decoder_create(opus_int32, int, int*)</code><br>
     * <i>native declaration : line 1339</i><br>
     * @deprecated use the safer methods {@link #opus_decoder_create(int, int, java.nio.IntBuffer)} and {@link #opus_decoder_create(int, int, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    PointerByReference opus_decoder_create(int Fs, int channels, IntByReference error);
    /**
     * Allocates and initializes a decoder state.<br>
     * @param [in] Fs <tt>opus_int32</tt>: Sample rate to decode at (Hz).<br>
     *                                     This must be one of 8000, 12000, 16000,<br>
     *                                     24000, or 48000.<br>
     * @param [in] channels <tt>int</tt>: Number of channels (1 or 2) to decode<br>
     * @param [out] error <tt>int*</tt>: #OPUS_OK Success or @ref opus_errorcodes<br>
     * Internally Opus stores data at 48000 Hz, so that should be the default<br>
     * value for Fs. However, the decoder can efficiently decode to buffers<br>
     * at 8, 12, 16, and 24 kHz so if for some reason the caller cannot use<br>
     * data at the full sample rate, or knows the compressed data doesn't<br>
     * use the full frequency range, it can request decoding at a reduced<br>
     * rate. Likewise, the decoder is capable of filling in either mono or<br>
     * interleaved stereo pcm buffers, at the caller's request.<br>
     * Original signature : <code>OpusDecoder* opus_decoder_create(opus_int32, int, int*)</code><br>
     * <i>native declaration : line 1339</i>
     */
    PointerByReference opus_decoder_create(int Fs, int channels, IntBuffer error);
    /**
     * Initializes a previously allocated decoder state.<br>
     * The state must be at least the size returned by opus_decoder_get_size().<br>
     * This is intended for applications which use their own allocator instead of malloc. @see opus_decoder_create,opus_decoder_get_size<br>
     * To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.<br>
     * @param [in] st <tt>OpusDecoder*</tt>: Decoder state.<br>
     * @param [in] Fs <tt>opus_int32</tt>: Sampling rate to decode to (Hz).<br>
     *                                     This must be one of 8000, 12000, 16000,<br>
     *                                     24000, or 48000.<br>
     * @param [in] channels <tt>int</tt>: Number of channels (1 or 2) to decode<br>
     * @retval #OPUS_OK Success or @ref opus_errorcodes<br>
     * Original signature : <code>int opus_decoder_init(OpusDecoder*, opus_int32, int)</code><br>
     * <i>native declaration : line 1356</i><br>
     * @deprecated use the safer method {@link #opus_decoder_init(com.sun.jna.ptr.PointerByReference, int, int)} instead
     */
    @Deprecated
    int opus_decoder_init(Pointer st, int Fs, int channels);
    /**
     * Initializes a previously allocated decoder state.<br>
     * The state must be at least the size returned by opus_decoder_get_size().<br>
     * This is intended for applications which use their own allocator instead of malloc. @see opus_decoder_create,opus_decoder_get_size<br>
     * To reset a previously initialized state, use the #OPUS_RESET_STATE CTL.<br>
     * @param [in] st <tt>OpusDecoder*</tt>: Decoder state.<br>
     * @param [in] Fs <tt>opus_int32</tt>: Sampling rate to decode to (Hz).<br>
     *                                     This must be one of 8000, 12000, 16000,<br>
     *                                     24000, or 48000.<br>
     * @param [in] channels <tt>int</tt>: Number of channels (1 or 2) to decode<br>
     * @retval #OPUS_OK Success or @ref opus_errorcodes<br>
     * Original signature : <code>int opus_decoder_init(OpusDecoder*, opus_int32, int)</code><br>
     * <i>native declaration : line 1356</i>
     */
    int opus_decoder_init(PointerByReference st, int Fs, int channels);
    /**
     * Decode an Opus packet.<br>
     * @param [in] st <tt>OpusDecoder*</tt>: Decoder state<br>
     * @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss<br>
     * @param [in] len <tt>opus_int32</tt>: Number of bytes in payload*<br>
     * @param [out] pcm <tt>opus_int16*</tt>: Output signal (interleaved if 2 channels). length<br>
     *  is frame_size*channels*sizeof(opus_int16)<br>
     * @param [in] frame_size Number of samples per channel of available space in \a pcm.<br>
     *  If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will<br>
     *  not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),<br>
     *  then frame_size needs to be exactly the duration of audio that is missing, otherwise the<br>
     *  decoder will not be in the optimal state to decode the next incoming packet. For the PLC and<br>
     *  FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.<br>
     * @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be<br>
     *  decoded. If no such data is available, the frame is decoded as if it were lost.<br>
     * @returns Number of decoded samples or @ref opus_errorcodes<br>
     * Original signature : <code>int opus_decode(OpusDecoder*, const unsigned char*, opus_int32, opus_int16*, int, int)</code><br>
     * <i>native declaration : line 1378</i><br>
     * @deprecated use the safer methods {@link #opus_decode(com.sun.jna.ptr.PointerByReference, byte[], int, java.nio.ShortBuffer, int, int)} and {@link #opus_decode(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, int, com.sun.jna.ptr.ShortByReference, int, int)} instead
     */
    @Deprecated
    int opus_decode(Pointer st, Pointer data, int len, ShortByReference pcm, int frame_size, int decode_fec);
    /**
     * Decode an Opus packet.<br>
     * @param [in] st <tt>OpusDecoder*</tt>: Decoder state<br>
     * @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss<br>
     * @param [in] len <tt>opus_int32</tt>: Number of bytes in payload*<br>
     * @param [out] pcm <tt>opus_int16*</tt>: Output signal (interleaved if 2 channels). length<br>
     *  is frame_size*channels*sizeof(opus_int16)<br>
     * @param [in] frame_size Number of samples per channel of available space in \a pcm.<br>
     *  If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will<br>
     *  not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),<br>
     *  then frame_size needs to be exactly the duration of audio that is missing, otherwise the<br>
     *  decoder will not be in the optimal state to decode the next incoming packet. For the PLC and<br>
     *  FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.<br>
     * @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be<br>
     *  decoded. If no such data is available, the frame is decoded as if it were lost.<br>
     * @returns Number of decoded samples or @ref opus_errorcodes<br>
     * Original signature : <code>int opus_decode(OpusDecoder*, const unsigned char*, opus_int32, opus_int16*, int, int)</code><br>
     * <i>native declaration : line 1378</i>
     */
    int opus_decode(PointerByReference st, byte data[], int len, ShortBuffer pcm, int frame_size, int decode_fec);
    /**
     * Decode an Opus packet.<br>
     * @param [in] st <tt>OpusDecoder*</tt>: Decoder state<br>
     * @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss<br>
     * @param [in] len <tt>opus_int32</tt>: Number of bytes in payload*<br>
     * @param [out] pcm <tt>opus_int16*</tt>: Output signal (interleaved if 2 channels). length<br>
     *  is frame_size*channels*sizeof(opus_int16)<br>
     * @param [in] frame_size Number of samples per channel of available space in \a pcm.<br>
     *  If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will<br>
     *  not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),<br>
     *  then frame_size needs to be exactly the duration of audio that is missing, otherwise the<br>
     *  decoder will not be in the optimal state to decode the next incoming packet. For the PLC and<br>
     *  FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.<br>
     * @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be<br>
     *  decoded. If no such data is available, the frame is decoded as if it were lost.<br>
     * @returns Number of decoded samples or @ref opus_errorcodes<br>
     * Original signature : <code>int opus_decode(OpusDecoder*, const unsigned char*, opus_int32, opus_int16*, int, int)</code><br>
     * <i>native declaration : line 1378</i>
     */
    int opus_decode(PointerByReference st, Pointer data, int len, ShortByReference pcm, int frame_size, int decode_fec);
    /**
     * Decode an Opus packet with floating point output.<br>
     * @param [in] st <tt>OpusDecoder*</tt>: Decoder state<br>
     * @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss<br>
     * @param [in] len <tt>opus_int32</tt>: Number of bytes in payload<br>
     * @param [out] pcm <tt>float*</tt>: Output signal (interleaved if 2 channels). length<br>
     *  is frame_size*channels*sizeof(float)<br>
     * @param [in] frame_size Number of samples per channel of available space in \a pcm.<br>
     *  If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will<br>
     *  not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),<br>
     *  then frame_size needs to be exactly the duration of audio that is missing, otherwise the<br>
     *  decoder will not be in the optimal state to decode the next incoming packet. For the PLC and<br>
     *  FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.<br>
     * @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be<br>
     *  decoded. If no such data is available the frame is decoded as if it were lost.<br>
     * @returns Number of decoded samples or @ref opus_errorcodes<br>
     * Original signature : <code>int opus_decode_float(OpusDecoder*, const unsigned char*, opus_int32, float*, int, int)</code><br>
     * <i>native declaration : line 1403</i><br>
     * @deprecated use the safer methods {@link #opus_decode_float(com.sun.jna.ptr.PointerByReference, byte[], int, java.nio.FloatBuffer, int, int)} and {@link #opus_decode_float(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, int, com.sun.jna.ptr.FloatByReference, int, int)} instead
     */
    @Deprecated
    int opus_decode_float(Pointer st, Pointer data, int len, FloatByReference pcm, int frame_size, int decode_fec);
    /**
     * Decode an Opus packet with floating point output.<br>
     * @param [in] st <tt>OpusDecoder*</tt>: Decoder state<br>
     * @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss<br>
     * @param [in] len <tt>opus_int32</tt>: Number of bytes in payload<br>
     * @param [out] pcm <tt>float*</tt>: Output signal (interleaved if 2 channels). length<br>
     *  is frame_size*channels*sizeof(float)<br>
     * @param [in] frame_size Number of samples per channel of available space in \a pcm.<br>
     *  If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will<br>
     *  not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),<br>
     *  then frame_size needs to be exactly the duration of audio that is missing, otherwise the<br>
     *  decoder will not be in the optimal state to decode the next incoming packet. For the PLC and<br>
     *  FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.<br>
     * @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be<br>
     *  decoded. If no such data is available the frame is decoded as if it were lost.<br>
     * @returns Number of decoded samples or @ref opus_errorcodes<br>
     * Original signature : <code>int opus_decode_float(OpusDecoder*, const unsigned char*, opus_int32, float*, int, int)</code><br>
     * <i>native declaration : line 1403</i>
     */
    int opus_decode_float(PointerByReference st, byte data[], int len, FloatBuffer pcm, int frame_size, int decode_fec);
    /**
     * Decode an Opus packet with floating point output.<br>
     * @param [in] st <tt>OpusDecoder*</tt>: Decoder state<br>
     * @param [in] data <tt>char*</tt>: Input payload. Use a NULL pointer to indicate packet loss<br>
     * @param [in] len <tt>opus_int32</tt>: Number of bytes in payload<br>
     * @param [out] pcm <tt>float*</tt>: Output signal (interleaved if 2 channels). length<br>
     *  is frame_size*channels*sizeof(float)<br>
     * @param [in] frame_size Number of samples per channel of available space in \a pcm.<br>
     *  If this is less than the maximum packet duration (120ms; 5760 for 48kHz), this function will<br>
     *  not be capable of decoding some packets. In the case of PLC (data==NULL) or FEC (decode_fec=1),<br>
     *  then frame_size needs to be exactly the duration of audio that is missing, otherwise the<br>
     *  decoder will not be in the optimal state to decode the next incoming packet. For the PLC and<br>
     *  FEC cases, frame_size <b>must</b> be a multiple of 2.5 ms.<br>
     * @param [in] decode_fec <tt>int</tt>: Flag (0 or 1) to request that any in-band forward error correction data be<br>
     *  decoded. If no such data is available the frame is decoded as if it were lost.<br>
     * @returns Number of decoded samples or @ref opus_errorcodes<br>
     * Original signature : <code>int opus_decode_float(OpusDecoder*, const unsigned char*, opus_int32, float*, int, int)</code><br>
     * <i>native declaration : line 1403</i>
     */
    int opus_decode_float(PointerByReference st, Pointer data, int len, FloatByReference pcm, int frame_size, int decode_fec);
    /**
     * Perform a CTL function on an Opus decoder.<br>
     * Generally the request and subsequent arguments are generated<br>
     * by a convenience macro.<br>
     * @param st <tt>OpusDecoder*</tt>: Decoder state.<br>
     * @param request This and all remaining parameters should be replaced by one<br>
     *                of the convenience macros in @ref opus_genericctls or<br>
     *                @ref opus_decoderctls.<br>
     * @see opus_genericctls<br>
     * @see opus_decoderctls<br>
     * Original signature : <code>int opus_decoder_ctl(OpusDecoder*, int, null)</code><br>
     * <i>native declaration : line 1423</i><br>
     * @deprecated use the safer method {@link #opus_decoder_ctl(com.sun.jna.ptr.PointerByReference, int, java.lang.Object)} instead
     */
    @Deprecated
    int opus_decoder_ctl(Pointer st, int request, Object... varArgs1);
    /**
     * Perform a CTL function on an Opus decoder.<br>
     * Generally the request and subsequent arguments are generated<br>
     * by a convenience macro.<br>
     * @param st <tt>OpusDecoder*</tt>: Decoder state.<br>
     * @param request This and all remaining parameters should be replaced by one<br>
     *                of the convenience macros in @ref opus_genericctls or<br>
     *                @ref opus_decoderctls.<br>
     * @see opus_genericctls<br>
     * @see opus_decoderctls<br>
     * Original signature : <code>int opus_decoder_ctl(OpusDecoder*, int, null)</code><br>
     * <i>native declaration : line 1423</i>
     */
    int opus_decoder_ctl(PointerByReference st, int request, Object... varArgs1);
    /**
     * Frees an <code>OpusDecoder</code> allocated by opus_decoder_create().<br>
     * @param[in] st <tt>OpusDecoder*</tt>: State to be freed.<br>
     * Original signature : <code>void opus_decoder_destroy(OpusDecoder*)</code><br>
     * <i>native declaration : line 1428</i><br>
     * @deprecated use the safer method {@link #opus_decoder_destroy(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    void opus_decoder_destroy(Pointer st);
    /**
     * Frees an <code>OpusDecoder</code> allocated by opus_decoder_create().<br>
     * @param[in] st <tt>OpusDecoder*</tt>: State to be freed.<br>
     * Original signature : <code>void opus_decoder_destroy(OpusDecoder*)</code><br>
     * <i>native declaration : line 1428</i>
     */
    void opus_decoder_destroy(PointerByReference st);
    /**
     * Parse an opus packet into one or more frames.<br>
     * Opus_decode will perform this operation internally so most applications do<br>
     * not need to use this function.<br>
     * This function does not copy the frames, the returned pointers are pointers into<br>
     * the input packet.<br>
     * @param [in] data <tt>char*</tt>: Opus packet to be parsed<br>
     * @param [in] len <tt>opus_int32</tt>: size of data<br>
     * @param [out] out_toc <tt>char*</tt>: TOC pointer<br>
     * @param [out] frames <tt>char*[48]</tt> encapsulated frames<br>
     * @param [out] size <tt>opus_int16[48]</tt> sizes of the encapsulated frames<br>
     * @param [out] payload_offset <tt>int*</tt>: returns the position of the payload within the packet (in bytes)<br>
     * @returns number of frames<br>
     * Original signature : <code>int opus_packet_parse(const unsigned char*, opus_int32, unsigned char*, const unsigned char*[48], opus_int16[48], int*)</code><br>
     * <i>native declaration : line 1443</i><br>
     * @deprecated use the safer methods {@link #opus_packet_parse(byte[], int, java.nio.ByteBuffer, byte[], java.nio.ShortBuffer, java.nio.IntBuffer)} and {@link #opus_packet_parse(com.sun.jna.Pointer, int, com.sun.jna.Pointer, com.sun.jna.ptr.PointerByReference, com.sun.jna.ptr.ShortByReference, com.sun.jna.ptr.IntByReference)} instead
     */
    @Deprecated
    int opus_packet_parse(Pointer data, int len, Pointer out_toc, PointerByReference frames, ShortByReference size, IntByReference payload_offset);
    /**
     * Parse an opus packet into one or more frames.<br>
     * Opus_decode will perform this operation internally so most applications do<br>
     * not need to use this function.<br>
     * This function does not copy the frames, the returned pointers are pointers into<br>
     * the input packet.<br>
     * @param [in] data <tt>char*</tt>: Opus packet to be parsed<br>
     * @param [in] len <tt>opus_int32</tt>: size of data<br>
     * @param [out] out_toc <tt>char*</tt>: TOC pointer<br>
     * @param [out] frames <tt>char*[48]</tt> encapsulated frames<br>
     * @param [out] size <tt>opus_int16[48]</tt> sizes of the encapsulated frames<br>
     * @param [out] payload_offset <tt>int*</tt>: returns the position of the payload within the packet (in bytes)<br>
     * @returns number of frames<br>
     * Original signature : <code>int opus_packet_parse(const unsigned char*, opus_int32, unsigned char*, const unsigned char*[48], opus_int16[48], int*)</code><br>
     * <i>native declaration : line 1443</i>
     */
    int opus_packet_parse(byte data[], int len, ByteBuffer out_toc, byte frames[], ShortBuffer size, IntBuffer payload_offset);
    /**
     * Gets the bandwidth of an Opus packet.<br>
     * @param [in] data <tt>char*</tt>: Opus packet<br>
     * @retval OPUS_BANDWIDTH_NARROWBAND Narrowband (4kHz bandpass)<br>
     * @retval OPUS_BANDWIDTH_MEDIUMBAND Mediumband (6kHz bandpass)<br>
     * @retval OPUS_BANDWIDTH_WIDEBAND Wideband (8kHz bandpass)<br>
     * @retval OPUS_BANDWIDTH_SUPERWIDEBAND Superwideband (12kHz bandpass)<br>
     * @retval OPUS_BANDWIDTH_FULLBAND Fullband (20kHz bandpass)<br>
     * @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type<br>
     * Original signature : <code>int opus_packet_get_bandwidth(const unsigned char*)</code><br>
     * <i>native declaration : line 1461</i><br>
     * @deprecated use the safer methods {@link #opus_packet_get_bandwidth(byte[])} and {@link #opus_packet_get_bandwidth(com.sun.jna.Pointer)} instead
     */
    @Deprecated
    int opus_packet_get_bandwidth(Pointer data);
    /**
     * Gets the bandwidth of an Opus packet.<br>
     * @param [in] data <tt>char*</tt>: Opus packet<br>
     * @retval OPUS_BANDWIDTH_NARROWBAND Narrowband (4kHz bandpass)<br>
     * @retval OPUS_BANDWIDTH_MEDIUMBAND Mediumband (6kHz bandpass)<br>
     * @retval OPUS_BANDWIDTH_WIDEBAND Wideband (8kHz bandpass)<br>
     * @retval OPUS_BANDWIDTH_SUPERWIDEBAND Superwideband (12kHz bandpass)<br>
     * @retval OPUS_BANDWIDTH_FULLBAND Fullband (20kHz bandpass)<br>
     * @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type<br>
     * Original signature : <code>int opus_packet_get_bandwidth(const unsigned char*)</code><br>
     * <i>native declaration : line 1461</i>
     */
    int opus_packet_get_bandwidth(byte data[]);
    /**
     * Gets the number of samples per frame from an Opus packet.<br>
     * @param [in] data <tt>char*</tt>: Opus packet.<br>
     *                                  This must contain at least one byte of<br>
     *                                  data.<br>
     * @param [in] Fs <tt>opus_int32</tt>: Sampling rate in Hz.<br>
     *                                     This must be a multiple of 400, or<br>
     *                                     inaccurate results will be returned.<br>
     * @returns Number of samples per frame.<br>
     * Original signature : <code>int opus_packet_get_samples_per_frame(const unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1472</i><br>
     * @deprecated use the safer methods {@link #opus_packet_get_samples_per_frame(byte[], int)} and {@link #opus_packet_get_samples_per_frame(com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    int opus_packet_get_samples_per_frame(Pointer data, int Fs);
    /**
     * Gets the number of samples per frame from an Opus packet.<br>
     * @param [in] data <tt>char*</tt>: Opus packet.<br>
     *                                  This must contain at least one byte of<br>
     *                                  data.<br>
     * @param [in] Fs <tt>opus_int32</tt>: Sampling rate in Hz.<br>
     *                                     This must be a multiple of 400, or<br>
     *                                     inaccurate results will be returned.<br>
     * @returns Number of samples per frame.<br>
     * Original signature : <code>int opus_packet_get_samples_per_frame(const unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1472</i>
     */
    int opus_packet_get_samples_per_frame(byte data[], int Fs);
    /**
     * Gets the number of channels from an Opus packet.<br>
     * @param [in] data <tt>char*</tt>: Opus packet<br>
     * @returns Number of channels<br>
     * @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type<br>
     * Original signature : <code>int opus_packet_get_nb_channels(const unsigned char*)</code><br>
     * <i>native declaration : line 1479</i><br>
     * @deprecated use the safer methods {@link #opus_packet_get_nb_channels(byte[])} and {@link #opus_packet_get_nb_channels(com.sun.jna.Pointer)} instead
     */
    @Deprecated
    int opus_packet_get_nb_channels(Pointer data);
    /**
     * Gets the number of channels from an Opus packet.<br>
     * @param [in] data <tt>char*</tt>: Opus packet<br>
     * @returns Number of channels<br>
     * @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type<br>
     * Original signature : <code>int opus_packet_get_nb_channels(const unsigned char*)</code><br>
     * <i>native declaration : line 1479</i>
     */
    int opus_packet_get_nb_channels(byte data[]);
    /**
     * Gets the number of frames in an Opus packet.<br>
     * @param [in] packet <tt>char*</tt>: Opus packet<br>
     * @param [in] len <tt>opus_int32</tt>: Length of packet<br>
     * @returns Number of frames<br>
     * @retval OPUS_BAD_ARG Insufficient data was passed to the function<br>
     * @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type<br>
     * Original signature : <code>int opus_packet_get_nb_frames(const unsigned char[], opus_int32)</code><br>
     * <i>native declaration : line 1488</i><br>
     * @deprecated use the safer methods {@link #opus_packet_get_nb_frames(byte[], int)} and {@link #opus_packet_get_nb_frames(com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    int opus_packet_get_nb_frames(Pointer packet, int len);
    /**
     * Gets the number of frames in an Opus packet.<br>
     * @param [in] packet <tt>char*</tt>: Opus packet<br>
     * @param [in] len <tt>opus_int32</tt>: Length of packet<br>
     * @returns Number of frames<br>
     * @retval OPUS_BAD_ARG Insufficient data was passed to the function<br>
     * @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type<br>
     * Original signature : <code>int opus_packet_get_nb_frames(const unsigned char[], opus_int32)</code><br>
     * <i>native declaration : line 1488</i>
     */
    int opus_packet_get_nb_frames(byte packet[], int len);
    /**
     * Gets the number of samples of an Opus packet.<br>
     * @param [in] packet <tt>char*</tt>: Opus packet<br>
     * @param [in] len <tt>opus_int32</tt>: Length of packet<br>
     * @param [in] Fs <tt>opus_int32</tt>: Sampling rate in Hz.<br>
     *                                     This must be a multiple of 400, or<br>
     *                                     inaccurate results will be returned.<br>
     * @returns Number of samples<br>
     * @retval OPUS_BAD_ARG Insufficient data was passed to the function<br>
     * @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type<br>
     * Original signature : <code>int opus_packet_get_nb_samples(const unsigned char[], opus_int32, opus_int32)</code><br>
     * <i>native declaration : line 1500</i><br>
     * @deprecated use the safer methods {@link #opus_packet_get_nb_samples(byte[], int, int)} and {@link #opus_packet_get_nb_samples(com.sun.jna.Pointer, int, int)} instead
     */
    @Deprecated
    int opus_packet_get_nb_samples(Pointer packet, int len, int Fs);
    /**
     * Gets the number of samples of an Opus packet.<br>
     * @param [in] packet <tt>char*</tt>: Opus packet<br>
     * @param [in] len <tt>opus_int32</tt>: Length of packet<br>
     * @param [in] Fs <tt>opus_int32</tt>: Sampling rate in Hz.<br>
     *                                     This must be a multiple of 400, or<br>
     *                                     inaccurate results will be returned.<br>
     * @returns Number of samples<br>
     * @retval OPUS_BAD_ARG Insufficient data was passed to the function<br>
     * @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type<br>
     * Original signature : <code>int opus_packet_get_nb_samples(const unsigned char[], opus_int32, opus_int32)</code><br>
     * <i>native declaration : line 1500</i>
     */
    int opus_packet_get_nb_samples(byte packet[], int len, int Fs);
    /**
     * Gets the number of samples of an Opus packet.<br>
     * @param [in] dec <tt>OpusDecoder*</tt>: Decoder state<br>
     * @param [in] packet <tt>char*</tt>: Opus packet<br>
     * @param [in] len <tt>opus_int32</tt>: Length of packet<br>
     * @returns Number of samples<br>
     * @retval OPUS_BAD_ARG Insufficient data was passed to the function<br>
     * @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type<br>
     * Original signature : <code>int opus_decoder_get_nb_samples(const OpusDecoder*, const unsigned char[], opus_int32)</code><br>
     * <i>native declaration : line 1510</i><br>
     * @deprecated use the safer methods {@link #opus_decoder_get_nb_samples(com.sun.jna.ptr.PointerByReference, byte[], int)} and {@link #opus_decoder_get_nb_samples(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    int opus_decoder_get_nb_samples(Pointer dec, Pointer packet, int len);
    /**
     * Gets the number of samples of an Opus packet.<br>
     * @param [in] dec <tt>OpusDecoder*</tt>: Decoder state<br>
     * @param [in] packet <tt>char*</tt>: Opus packet<br>
     * @param [in] len <tt>opus_int32</tt>: Length of packet<br>
     * @returns Number of samples<br>
     * @retval OPUS_BAD_ARG Insufficient data was passed to the function<br>
     * @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type<br>
     * Original signature : <code>int opus_decoder_get_nb_samples(const OpusDecoder*, const unsigned char[], opus_int32)</code><br>
     * <i>native declaration : line 1510</i>
     */
    int opus_decoder_get_nb_samples(PointerByReference dec, byte packet[], int len);
    /**
     * Gets the number of samples of an Opus packet.<br>
     * @param [in] dec <tt>OpusDecoder*</tt>: Decoder state<br>
     * @param [in] packet <tt>char*</tt>: Opus packet<br>
     * @param [in] len <tt>opus_int32</tt>: Length of packet<br>
     * @returns Number of samples<br>
     * @retval OPUS_BAD_ARG Insufficient data was passed to the function<br>
     * @retval OPUS_INVALID_PACKET The compressed data passed is corrupted or of an unsupported type<br>
     * Original signature : <code>int opus_decoder_get_nb_samples(const OpusDecoder*, const unsigned char[], opus_int32)</code><br>
     * <i>native declaration : line 1510</i>
     */
    int opus_decoder_get_nb_samples(PointerByReference dec, Pointer packet, int len);
    /**
     * Applies soft-clipping to bring a float signal within the [-1,1] range. If<br>
     * the signal is already in that range, nothing is done. If there are values<br>
     * outside of [-1,1], then the signal is clipped as smoothly as possible to<br>
     * both fit in the range and avoid creating excessive distortion in the<br>
     * process.<br>
     * @param [in,out] pcm <tt>float*</tt>: Input PCM and modified PCM<br>
     * @param [in] frame_size <tt>int</tt> Number of samples per channel to process<br>
     * @param [in] channels <tt>int</tt>: Number of channels<br>
     * @param [in,out] softclip_mem <tt>float*</tt>: State memory for the soft clipping process (one float per channel, initialized to zero)<br>
     * Original signature : <code>void opus_pcm_soft_clip(float*, int, int, float*)</code><br>
     * <i>native declaration : line 1522</i><br>
     * @deprecated use the safer methods {@link #opus_pcm_soft_clip(java.nio.FloatBuffer, int, int, java.nio.FloatBuffer)} and {@link #opus_pcm_soft_clip(com.sun.jna.ptr.FloatByReference, int, int, com.sun.jna.ptr.FloatByReference)} instead
     */
    @Deprecated
    void opus_pcm_soft_clip(FloatByReference pcm, int frame_size, int channels, FloatByReference softclip_mem);
    /**
     * Applies soft-clipping to bring a float signal within the [-1,1] range. If<br>
     * the signal is already in that range, nothing is done. If there are values<br>
     * outside of [-1,1], then the signal is clipped as smoothly as possible to<br>
     * both fit in the range and avoid creating excessive distortion in the<br>
     * process.<br>
     * @param [in,out] pcm <tt>float*</tt>: Input PCM and modified PCM<br>
     * @param [in] frame_size <tt>int</tt> Number of samples per channel to process<br>
     * @param [in] channels <tt>int</tt>: Number of channels<br>
     * @param [in,out] softclip_mem <tt>float*</tt>: State memory for the soft clipping process (one float per channel, initialized to zero)<br>
     * Original signature : <code>void opus_pcm_soft_clip(float*, int, int, float*)</code><br>
     * <i>native declaration : line 1522</i>
     */
    void opus_pcm_soft_clip(FloatBuffer pcm, int frame_size, int channels, FloatBuffer softclip_mem);
    /**
     * Gets the size of an <code>OpusRepacketizer</code> structure.<br>
     * @returns The size in bytes.<br>
     * Original signature : <code>int opus_repacketizer_get_size()</code><br>
     * <i>native declaration : line 1675</i>
     */
    int opus_repacketizer_get_size();
    /**
     * (Re)initializes a previously allocated repacketizer state.<br>
     * The state must be at least the size returned by opus_repacketizer_get_size().<br>
     * This can be used for applications which use their own allocator instead of<br>
     * malloc().<br>
     * It must also be called to reset the queue of packets waiting to be<br>
     * repacketized, which is necessary if the maximum packet duration of 120 ms<br>
     * is reached or if you wish to submit packets with a different Opus<br>
     * configuration (coding mode, audio bandwidth, frame size, or channel count).<br>
     * Failure to do so will prevent a new packet from being added with<br>
     * opus_repacketizer_cat().<br>
     * @see opus_repacketizer_create<br>
     * @see opus_repacketizer_get_size<br>
     * @see opus_repacketizer_cat<br>
     * @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state to<br>
     *                                       (re)initialize.<br>
     * @returns A pointer to the same repacketizer state that was passed in.<br>
     * Original signature : <code>OpusRepacketizer* opus_repacketizer_init(OpusRepacketizer*)</code><br>
     * <i>native declaration : line 1694</i><br>
     * @deprecated use the safer method {@link #opus_repacketizer_init(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    PointerByReference opus_repacketizer_init(Pointer rp);
    /**
     * (Re)initializes a previously allocated repacketizer state.<br>
     * The state must be at least the size returned by opus_repacketizer_get_size().<br>
     * This can be used for applications which use their own allocator instead of<br>
     * malloc().<br>
     * It must also be called to reset the queue of packets waiting to be<br>
     * repacketized, which is necessary if the maximum packet duration of 120 ms<br>
     * is reached or if you wish to submit packets with a different Opus<br>
     * configuration (coding mode, audio bandwidth, frame size, or channel count).<br>
     * Failure to do so will prevent a new packet from being added with<br>
     * opus_repacketizer_cat().<br>
     * @see opus_repacketizer_create<br>
     * @see opus_repacketizer_get_size<br>
     * @see opus_repacketizer_cat<br>
     * @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state to<br>
     *                                       (re)initialize.<br>
     * @returns A pointer to the same repacketizer state that was passed in.<br>
     * Original signature : <code>OpusRepacketizer* opus_repacketizer_init(OpusRepacketizer*)</code><br>
     * <i>native declaration : line 1694</i>
     */
    PointerByReference opus_repacketizer_init(PointerByReference rp);
    /**
     * Allocates memory and initializes the new repacketizer with<br>
     * opus_repacketizer_init().<br>
     * Original signature : <code>OpusRepacketizer* opus_repacketizer_create()</code><br>
     * <i>native declaration : line 1699</i>
     */
    PointerByReference opus_repacketizer_create();
    /**
     * Frees an <code>OpusRepacketizer</code> allocated by<br>
     * opus_repacketizer_create().<br>
     * @param[in] rp <tt>OpusRepacketizer*</tt>: State to be freed.<br>
     * Original signature : <code>void opus_repacketizer_destroy(OpusRepacketizer*)</code><br>
     * <i>native declaration : line 1705</i><br>
     * @deprecated use the safer method {@link #opus_repacketizer_destroy(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    void opus_repacketizer_destroy(Pointer rp);
    /**
     * Frees an <code>OpusRepacketizer</code> allocated by<br>
     * opus_repacketizer_create().<br>
     * @param[in] rp <tt>OpusRepacketizer*</tt>: State to be freed.<br>
     * Original signature : <code>void opus_repacketizer_destroy(OpusRepacketizer*)</code><br>
     * <i>native declaration : line 1705</i>
     */
    void opus_repacketizer_destroy(PointerByReference rp);
    /**
     * Add a packet to the current repacketizer state.<br>
     * This packet must match the configuration of any packets already submitted<br>
     * for repacketization since the last call to opus_repacketizer_init().<br>
     * This means that it must have the same coding mode, audio bandwidth, frame<br>
     * size, and channel count.<br>
     * This can be checked in advance by examining the top 6 bits of the first<br>
     * byte of the packet, and ensuring they match the top 6 bits of the first<br>
     * byte of any previously submitted packet.<br>
     * The total duration of audio in the repacketizer state also must not exceed<br>
     * 120 ms, the maximum duration of a single packet, after adding this packet.<br>
     * The contents of the current repacketizer state can be extracted into new<br>
     * packets using opus_repacketizer_out() or opus_repacketizer_out_range().<br>
     * In order to add a packet with a different configuration or to add more<br>
     * audio beyond 120 ms, you must clear the repacketizer state by calling<br>
     * opus_repacketizer_init().<br>
     * If a packet is too large to add to the current repacketizer state, no part<br>
     * of it is added, even if it contains multiple frames, some of which might<br>
     * fit.<br>
     * If you wish to be able to add parts of such packets, you should first use<br>
     * another repacketizer to split the packet into pieces and add them<br>
     * individually.<br>
     * @see opus_repacketizer_out_range<br>
     * @see opus_repacketizer_out<br>
     * @see opus_repacketizer_init<br>
     * @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state to which to<br>
     *                                       add the packet.<br>
     * @param[in] data <tt>const unsigned char*</tt>: The packet data.<br>
     *                                                The application must ensure<br>
     *                                                this pointer remains valid<br>
     *                                                until the next call to<br>
     *                                                opus_repacketizer_init() or<br>
     *                                                opus_repacketizer_destroy().<br>
     * @param len <tt>opus_int32</tt>: The number of bytes in the packet data.<br>
     * @returns An error code indicating whether or not the operation succeeded.<br>
     * @retval #OPUS_OK The packet's contents have been added to the repacketizer<br>
     *                  state.<br>
     * @retval #OPUS_INVALID_PACKET The packet did not have a valid TOC sequence,<br>
     *                              the packet's TOC sequence was not compatible<br>
     *                              with previously submitted packets (because<br>
     *                              the coding mode, audio bandwidth, frame size,<br>
     *                              or channel count did not match), or adding<br>
     *                              this packet would increase the total amount of<br>
     *                              audio stored in the repacketizer state to more<br>
     *                              than 120 ms.<br>
     * Original signature : <code>int opus_repacketizer_cat(OpusRepacketizer*, const unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1754</i><br>
     * @deprecated use the safer methods {@link #opus_repacketizer_cat(com.sun.jna.ptr.PointerByReference, byte[], int)} and {@link #opus_repacketizer_cat(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    int opus_repacketizer_cat(Pointer rp, Pointer data, int len);
    /**
     * Add a packet to the current repacketizer state.<br>
     * This packet must match the configuration of any packets already submitted<br>
     * for repacketization since the last call to opus_repacketizer_init().<br>
     * This means that it must have the same coding mode, audio bandwidth, frame<br>
     * size, and channel count.<br>
     * This can be checked in advance by examining the top 6 bits of the first<br>
     * byte of the packet, and ensuring they match the top 6 bits of the first<br>
     * byte of any previously submitted packet.<br>
     * The total duration of audio in the repacketizer state also must not exceed<br>
     * 120 ms, the maximum duration of a single packet, after adding this packet.<br>
     * The contents of the current repacketizer state can be extracted into new<br>
     * packets using opus_repacketizer_out() or opus_repacketizer_out_range().<br>
     * In order to add a packet with a different configuration or to add more<br>
     * audio beyond 120 ms, you must clear the repacketizer state by calling<br>
     * opus_repacketizer_init().<br>
     * If a packet is too large to add to the current repacketizer state, no part<br>
     * of it is added, even if it contains multiple frames, some of which might<br>
     * fit.<br>
     * If you wish to be able to add parts of such packets, you should first use<br>
     * another repacketizer to split the packet into pieces and add them<br>
     * individually.<br>
     * @see opus_repacketizer_out_range<br>
     * @see opus_repacketizer_out<br>
     * @see opus_repacketizer_init<br>
     * @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state to which to<br>
     *                                       add the packet.<br>
     * @param[in] data <tt>const unsigned char*</tt>: The packet data.<br>
     *                                                The application must ensure<br>
     *                                                this pointer remains valid<br>
     *                                                until the next call to<br>
     *                                                opus_repacketizer_init() or<br>
     *                                                opus_repacketizer_destroy().<br>
     * @param len <tt>opus_int32</tt>: The number of bytes in the packet data.<br>
     * @returns An error code indicating whether or not the operation succeeded.<br>
     * @retval #OPUS_OK The packet's contents have been added to the repacketizer<br>
     *                  state.<br>
     * @retval #OPUS_INVALID_PACKET The packet did not have a valid TOC sequence,<br>
     *                              the packet's TOC sequence was not compatible<br>
     *                              with previously submitted packets (because<br>
     *                              the coding mode, audio bandwidth, frame size,<br>
     *                              or channel count did not match), or adding<br>
     *                              this packet would increase the total amount of<br>
     *                              audio stored in the repacketizer state to more<br>
     *                              than 120 ms.<br>
     * Original signature : <code>int opus_repacketizer_cat(OpusRepacketizer*, const unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1754</i>
     */
    int opus_repacketizer_cat(PointerByReference rp, byte data[], int len);
    /**
     * Add a packet to the current repacketizer state.<br>
     * This packet must match the configuration of any packets already submitted<br>
     * for repacketization since the last call to opus_repacketizer_init().<br>
     * This means that it must have the same coding mode, audio bandwidth, frame<br>
     * size, and channel count.<br>
     * This can be checked in advance by examining the top 6 bits of the first<br>
     * byte of the packet, and ensuring they match the top 6 bits of the first<br>
     * byte of any previously submitted packet.<br>
     * The total duration of audio in the repacketizer state also must not exceed<br>
     * 120 ms, the maximum duration of a single packet, after adding this packet.<br>
     * The contents of the current repacketizer state can be extracted into new<br>
     * packets using opus_repacketizer_out() or opus_repacketizer_out_range().<br>
     * In order to add a packet with a different configuration or to add more<br>
     * audio beyond 120 ms, you must clear the repacketizer state by calling<br>
     * opus_repacketizer_init().<br>
     * If a packet is too large to add to the current repacketizer state, no part<br>
     * of it is added, even if it contains multiple frames, some of which might<br>
     * fit.<br>
     * If you wish to be able to add parts of such packets, you should first use<br>
     * another repacketizer to split the packet into pieces and add them<br>
     * individually.<br>
     * @see opus_repacketizer_out_range<br>
     * @see opus_repacketizer_out<br>
     * @see opus_repacketizer_init<br>
     * @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state to which to<br>
     *                                       add the packet.<br>
     * @param[in] data <tt>const unsigned char*</tt>: The packet data.<br>
     *                                                The application must ensure<br>
     *                                                this pointer remains valid<br>
     *                                                until the next call to<br>
     *                                                opus_repacketizer_init() or<br>
     *                                                opus_repacketizer_destroy().<br>
     * @param len <tt>opus_int32</tt>: The number of bytes in the packet data.<br>
     * @returns An error code indicating whether or not the operation succeeded.<br>
     * @retval #OPUS_OK The packet's contents have been added to the repacketizer<br>
     *                  state.<br>
     * @retval #OPUS_INVALID_PACKET The packet did not have a valid TOC sequence,<br>
     *                              the packet's TOC sequence was not compatible<br>
     *                              with previously submitted packets (because<br>
     *                              the coding mode, audio bandwidth, frame size,<br>
     *                              or channel count did not match), or adding<br>
     *                              this packet would increase the total amount of<br>
     *                              audio stored in the repacketizer state to more<br>
     *                              than 120 ms.<br>
     * Original signature : <code>int opus_repacketizer_cat(OpusRepacketizer*, const unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1754</i>
     */
    int opus_repacketizer_cat(PointerByReference rp, Pointer data, int len);
    /**
     * Construct a new packet from data previously submitted to the repacketizer<br>
     * state via opus_repacketizer_cat().<br>
     * @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state from which to<br>
     *                                       construct the new packet.<br>
     * @param begin <tt>int</tt>: The index of the first frame in the current<br>
     *                            repacketizer state to include in the output.<br>
     * @param end <tt>int</tt>: One past the index of the last frame in the<br>
     *                          current repacketizer state to include in the<br>
     *                          output.<br>
     * @param[out] data <tt>const unsigned char*</tt>: The buffer in which to<br>
     *                                                 store the output packet.<br>
     * @param maxlen <tt>opus_int32</tt>: The maximum number of bytes to store in<br>
     *                                    the output buffer. In order to guarantee<br>
     *                                    success, this should be at least<br>
     *                                    <code>1276</code> for a single frame,<br>
     *                                    or for multiple frames,<br>
     *                                    <code>1277*(end-begin)</code>.<br>
     *                                    However, <code>1*(end-begin)</code> plus<br>
     *                                    the size of all packet data submitted to<br>
     *                                    the repacketizer since the last call to<br>
     *                                    opus_repacketizer_init() or<br>
     *                                    opus_repacketizer_create() is also<br>
     *                                    sufficient, and possibly much smaller.<br>
     * @returns The total size of the output packet on success, or an error code<br>
     *          on failure.<br>
     * @retval #OPUS_BAD_ARG <code>[begin,end)</code> was an invalid range of<br>
     *                       frames (begin < 0, begin >= end, or end ><br>
     *                       opus_repacketizer_get_nb_frames()).<br>
     * @retval #OPUS_BUFFER_TOO_SMALL \a maxlen was insufficient to contain the<br>
     *                                complete output packet.<br>
     * Original signature : <code>opus_int32 opus_repacketizer_out_range(OpusRepacketizer*, int, int, unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1788</i><br>
     * @deprecated use the safer methods {@link #opus_repacketizer_out_range(com.sun.jna.ptr.PointerByReference, int, int, java.nio.ByteBuffer, int)} and {@link #opus_repacketizer_out_range(com.sun.jna.ptr.PointerByReference, int, int, com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    int opus_repacketizer_out_range(Pointer rp, int begin, int end, Pointer data, int maxlen);
    /**
     * Construct a new packet from data previously submitted to the repacketizer<br>
     * state via opus_repacketizer_cat().<br>
     * @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state from which to<br>
     *                                       construct the new packet.<br>
     * @param begin <tt>int</tt>: The index of the first frame in the current<br>
     *                            repacketizer state to include in the output.<br>
     * @param end <tt>int</tt>: One past the index of the last frame in the<br>
     *                          current repacketizer state to include in the<br>
     *                          output.<br>
     * @param[out] data <tt>const unsigned char*</tt>: The buffer in which to<br>
     *                                                 store the output packet.<br>
     * @param maxlen <tt>opus_int32</tt>: The maximum number of bytes to store in<br>
     *                                    the output buffer. In order to guarantee<br>
     *                                    success, this should be at least<br>
     *                                    <code>1276</code> for a single frame,<br>
     *                                    or for multiple frames,<br>
     *                                    <code>1277*(end-begin)</code>.<br>
     *                                    However, <code>1*(end-begin)</code> plus<br>
     *                                    the size of all packet data submitted to<br>
     *                                    the repacketizer since the last call to<br>
     *                                    opus_repacketizer_init() or<br>
     *                                    opus_repacketizer_create() is also<br>
     *                                    sufficient, and possibly much smaller.<br>
     * @returns The total size of the output packet on success, or an error code<br>
     *          on failure.<br>
     * @retval #OPUS_BAD_ARG <code>[begin,end)</code> was an invalid range of<br>
     *                       frames (begin < 0, begin >= end, or end ><br>
     *                       opus_repacketizer_get_nb_frames()).<br>
     * @retval #OPUS_BUFFER_TOO_SMALL \a maxlen was insufficient to contain the<br>
     *                                complete output packet.<br>
     * Original signature : <code>opus_int32 opus_repacketizer_out_range(OpusRepacketizer*, int, int, unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1788</i>
     */
    int opus_repacketizer_out_range(PointerByReference rp, int begin, int end, ByteBuffer data, int maxlen);
    /**
     * Construct a new packet from data previously submitted to the repacketizer<br>
     * state via opus_repacketizer_cat().<br>
     * @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state from which to<br>
     *                                       construct the new packet.<br>
     * @param begin <tt>int</tt>: The index of the first frame in the current<br>
     *                            repacketizer state to include in the output.<br>
     * @param end <tt>int</tt>: One past the index of the last frame in the<br>
     *                          current repacketizer state to include in the<br>
     *                          output.<br>
     * @param[out] data <tt>const unsigned char*</tt>: The buffer in which to<br>
     *                                                 store the output packet.<br>
     * @param maxlen <tt>opus_int32</tt>: The maximum number of bytes to store in<br>
     *                                    the output buffer. In order to guarantee<br>
     *                                    success, this should be at least<br>
     *                                    <code>1276</code> for a single frame,<br>
     *                                    or for multiple frames,<br>
     *                                    <code>1277*(end-begin)</code>.<br>
     *                                    However, <code>1*(end-begin)</code> plus<br>
     *                                    the size of all packet data submitted to<br>
     *                                    the repacketizer since the last call to<br>
     *                                    opus_repacketizer_init() or<br>
     *                                    opus_repacketizer_create() is also<br>
     *                                    sufficient, and possibly much smaller.<br>
     * @returns The total size of the output packet on success, or an error code<br>
     *          on failure.<br>
     * @retval #OPUS_BAD_ARG <code>[begin,end)</code> was an invalid range of<br>
     *                       frames (begin < 0, begin >= end, or end ><br>
     *                       opus_repacketizer_get_nb_frames()).<br>
     * @retval #OPUS_BUFFER_TOO_SMALL \a maxlen was insufficient to contain the<br>
     *                                complete output packet.<br>
     * Original signature : <code>opus_int32 opus_repacketizer_out_range(OpusRepacketizer*, int, int, unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1788</i>
     */
    int opus_repacketizer_out_range(PointerByReference rp, int begin, int end, Pointer data, int maxlen);
    /**
     * Return the total number of frames contained in packet data submitted to<br>
     * the repacketizer state so far via opus_repacketizer_cat() since the last<br>
     * call to opus_repacketizer_init() or opus_repacketizer_create().<br>
     * This defines the valid range of packets that can be extracted with<br>
     * opus_repacketizer_out_range() or opus_repacketizer_out().<br>
     * @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state containing the<br>
     *                                       frames.<br>
     * @returns The total number of frames contained in the packet data submitted<br>
     *          to the repacketizer state.<br>
     * Original signature : <code>int opus_repacketizer_get_nb_frames(OpusRepacketizer*)</code><br>
     * <i>native declaration : line 1800</i><br>
     * @deprecated use the safer method {@link #opus_repacketizer_get_nb_frames(com.sun.jna.ptr.PointerByReference)} instead
     */
    @Deprecated
    int opus_repacketizer_get_nb_frames(Pointer rp);
    /**
     * Return the total number of frames contained in packet data submitted to<br>
     * the repacketizer state so far via opus_repacketizer_cat() since the last<br>
     * call to opus_repacketizer_init() or opus_repacketizer_create().<br>
     * This defines the valid range of packets that can be extracted with<br>
     * opus_repacketizer_out_range() or opus_repacketizer_out().<br>
     * @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state containing the<br>
     *                                       frames.<br>
     * @returns The total number of frames contained in the packet data submitted<br>
     *          to the repacketizer state.<br>
     * Original signature : <code>int opus_repacketizer_get_nb_frames(OpusRepacketizer*)</code><br>
     * <i>native declaration : line 1800</i>
     */
    int opus_repacketizer_get_nb_frames(PointerByReference rp);
    /**
     * Construct a new packet from data previously submitted to the repacketizer<br>
     * state via opus_repacketizer_cat().<br>
     * This is a convenience routine that returns all the data submitted so far<br>
     * in a single packet.<br>
     * It is equivalent to calling<br>
     * @code<br>
     * opus_repacketizer_out_range(rp, 0, opus_repacketizer_get_nb_frames(rp),<br>
     *                             data, maxlen)<br>
     * @endcode<br>
     * @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state from which to<br>
     *                                       construct the new packet.<br>
     * @param[out] data <tt>const unsigned char*</tt>: The buffer in which to<br>
     *                                                 store the output packet.<br>
     * @param maxlen <tt>opus_int32</tt>: The maximum number of bytes to store in<br>
     *                                    the output buffer. In order to guarantee<br>
     *                                    success, this should be at least<br>
     *                                    <code>1277*opus_repacketizer_get_nb_frames(rp)</code>.<br>
     *                                    However,<br>
     *                                    <code>1*opus_repacketizer_get_nb_frames(rp)</code><br>
     *                                    plus the size of all packet data<br>
     *                                    submitted to the repacketizer since the<br>
     *                                    last call to opus_repacketizer_init() or<br>
     *                                    opus_repacketizer_create() is also<br>
     *                                    sufficient, and possibly much smaller.<br>
     * @returns The total size of the output packet on success, or an error code<br>
     *          on failure.<br>
     * @retval #OPUS_BUFFER_TOO_SMALL \a maxlen was insufficient to contain the<br>
     *                                complete output packet.<br>
     * Original signature : <code>opus_int32 opus_repacketizer_out(OpusRepacketizer*, unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1831</i><br>
     * @deprecated use the safer methods {@link #opus_repacketizer_out(com.sun.jna.ptr.PointerByReference, java.nio.ByteBuffer, int)} and {@link #opus_repacketizer_out(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    int opus_repacketizer_out(Pointer rp, Pointer data, int maxlen);
    /**
     * Construct a new packet from data previously submitted to the repacketizer<br>
     * state via opus_repacketizer_cat().<br>
     * This is a convenience routine that returns all the data submitted so far<br>
     * in a single packet.<br>
     * It is equivalent to calling<br>
     * @code<br>
     * opus_repacketizer_out_range(rp, 0, opus_repacketizer_get_nb_frames(rp),<br>
     *                             data, maxlen)<br>
     * @endcode<br>
     * @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state from which to<br>
     *                                       construct the new packet.<br>
     * @param[out] data <tt>const unsigned char*</tt>: The buffer in which to<br>
     *                                                 store the output packet.<br>
     * @param maxlen <tt>opus_int32</tt>: The maximum number of bytes to store in<br>
     *                                    the output buffer. In order to guarantee<br>
     *                                    success, this should be at least<br>
     *                                    <code>1277*opus_repacketizer_get_nb_frames(rp)</code>.<br>
     *                                    However,<br>
     *                                    <code>1*opus_repacketizer_get_nb_frames(rp)</code><br>
     *                                    plus the size of all packet data<br>
     *                                    submitted to the repacketizer since the<br>
     *                                    last call to opus_repacketizer_init() or<br>
     *                                    opus_repacketizer_create() is also<br>
     *                                    sufficient, and possibly much smaller.<br>
     * @returns The total size of the output packet on success, or an error code<br>
     *          on failure.<br>
     * @retval #OPUS_BUFFER_TOO_SMALL \a maxlen was insufficient to contain the<br>
     *                                complete output packet.<br>
     * Original signature : <code>opus_int32 opus_repacketizer_out(OpusRepacketizer*, unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1831</i>
     */
    int opus_repacketizer_out(PointerByReference rp, ByteBuffer data, int maxlen);
    /**
     * Construct a new packet from data previously submitted to the repacketizer<br>
     * state via opus_repacketizer_cat().<br>
     * This is a convenience routine that returns all the data submitted so far<br>
     * in a single packet.<br>
     * It is equivalent to calling<br>
     * @code<br>
     * opus_repacketizer_out_range(rp, 0, opus_repacketizer_get_nb_frames(rp),<br>
     *                             data, maxlen)<br>
     * @endcode<br>
     * @param rp <tt>OpusRepacketizer*</tt>: The repacketizer state from which to<br>
     *                                       construct the new packet.<br>
     * @param[out] data <tt>const unsigned char*</tt>: The buffer in which to<br>
     *                                                 store the output packet.<br>
     * @param maxlen <tt>opus_int32</tt>: The maximum number of bytes to store in<br>
     *                                    the output buffer. In order to guarantee<br>
     *                                    success, this should be at least<br>
     *                                    <code>1277*opus_repacketizer_get_nb_frames(rp)</code>.<br>
     *                                    However,<br>
     *                                    <code>1*opus_repacketizer_get_nb_frames(rp)</code><br>
     *                                    plus the size of all packet data<br>
     *                                    submitted to the repacketizer since the<br>
     *                                    last call to opus_repacketizer_init() or<br>
     *                                    opus_repacketizer_create() is also<br>
     *                                    sufficient, and possibly much smaller.<br>
     * @returns The total size of the output packet on success, or an error code<br>
     *          on failure.<br>
     * @retval #OPUS_BUFFER_TOO_SMALL \a maxlen was insufficient to contain the<br>
     *                                complete output packet.<br>
     * Original signature : <code>opus_int32 opus_repacketizer_out(OpusRepacketizer*, unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1831</i>
     */
    int opus_repacketizer_out(PointerByReference rp, Pointer data, int maxlen);
    /**
     * Pads a given Opus packet to a larger size (possibly changing the TOC sequence).<br>
     * @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the<br>
     *                                                   packet to pad.<br>
     * @param len <tt>opus_int32</tt>: The size of the packet.<br>
     *                                 This must be at least 1.<br>
     * @param new_len <tt>opus_int32</tt>: The desired size of the packet after padding.<br>
     *                                 This must be at least as large as len.<br>
     * @returns an error code<br>
     * @retval #OPUS_OK \a on success.<br>
     * @retval #OPUS_BAD_ARG \a len was less than 1 or new_len was less than len.<br>
     * @retval #OPUS_INVALID_PACKET \a data did not contain a valid Opus packet.<br>
     * Original signature : <code>int opus_packet_pad(unsigned char*, opus_int32, opus_int32)</code><br>
     * <i>native declaration : line 1845</i><br>
     * @deprecated use the safer methods {@link #opus_packet_pad(java.nio.ByteBuffer, int, int)} and {@link #opus_packet_pad(com.sun.jna.Pointer, int, int)} instead
     */
    @Deprecated
    int opus_packet_pad(Pointer data, int len, int new_len);
    /**
     * Pads a given Opus packet to a larger size (possibly changing the TOC sequence).<br>
     * @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the<br>
     *                                                   packet to pad.<br>
     * @param len <tt>opus_int32</tt>: The size of the packet.<br>
     *                                 This must be at least 1.<br>
     * @param new_len <tt>opus_int32</tt>: The desired size of the packet after padding.<br>
     *                                 This must be at least as large as len.<br>
     * @returns an error code<br>
     * @retval #OPUS_OK \a on success.<br>
     * @retval #OPUS_BAD_ARG \a len was less than 1 or new_len was less than len.<br>
     * @retval #OPUS_INVALID_PACKET \a data did not contain a valid Opus packet.<br>
     * Original signature : <code>int opus_packet_pad(unsigned char*, opus_int32, opus_int32)</code><br>
     * <i>native declaration : line 1845</i>
     */
    int opus_packet_pad(ByteBuffer data, int len, int new_len);
    /**
     * Remove all padding from a given Opus packet and rewrite the TOC sequence to<br>
     * minimize space usage.<br>
     * @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the<br>
     *                                                   packet to strip.<br>
     * @param len <tt>opus_int32</tt>: The size of the packet.<br>
     *                                 This must be at least 1.<br>
     * @returns The new size of the output packet on success, or an error code<br>
     *          on failure.<br>
     * @retval #OPUS_BAD_ARG \a len was less than 1.<br>
     * @retval #OPUS_INVALID_PACKET \a data did not contain a valid Opus packet.<br>
     * Original signature : <code>opus_int32 opus_packet_unpad(unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1858</i><br>
     * @deprecated use the safer methods {@link #opus_packet_unpad(java.nio.ByteBuffer, int)} and {@link #opus_packet_unpad(com.sun.jna.Pointer, int)} instead
     */
    @Deprecated
    int opus_packet_unpad(Pointer data, int len);
    /**
     * Remove all padding from a given Opus packet and rewrite the TOC sequence to<br>
     * minimize space usage.<br>
     * @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the<br>
     *                                                   packet to strip.<br>
     * @param len <tt>opus_int32</tt>: The size of the packet.<br>
     *                                 This must be at least 1.<br>
     * @returns The new size of the output packet on success, or an error code<br>
     *          on failure.<br>
     * @retval #OPUS_BAD_ARG \a len was less than 1.<br>
     * @retval #OPUS_INVALID_PACKET \a data did not contain a valid Opus packet.<br>
     * Original signature : <code>opus_int32 opus_packet_unpad(unsigned char*, opus_int32)</code><br>
     * <i>native declaration : line 1858</i>
     */
    int opus_packet_unpad(ByteBuffer data, int len);
    /**
     * Pads a given Opus multi-stream packet to a larger size (possibly changing the TOC sequence).<br>
     * @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the<br>
     *                                                   packet to pad.<br>
     * @param len <tt>opus_int32</tt>: The size of the packet.<br>
     *                                 This must be at least 1.<br>
     * @param new_len <tt>opus_int32</tt>: The desired size of the packet after padding.<br>
     *                                 This must be at least 1.<br>
     * @param nb_streams <tt>opus_int32</tt>: The number of streams (not channels) in the packet.<br>
     *                                 This must be at least as large as len.<br>
     * @returns an error code<br>
     * @retval #OPUS_OK \a on success.<br>
     * @retval #OPUS_BAD_ARG \a len was less than 1.<br>
     * @retval #OPUS_INVALID_PACKET \a data did not contain a valid Opus packet.<br>
     * Original signature : <code>int opus_multistream_packet_pad(unsigned char*, opus_int32, opus_int32, int)</code><br>
     * <i>native declaration : line 1874</i><br>
     * @deprecated use the safer methods {@link #opus_multistream_packet_pad(java.nio.ByteBuffer, int, int, int)} and {@link #opus_multistream_packet_pad(com.sun.jna.Pointer, int, int, int)} instead
     */
    @Deprecated
    int opus_multistream_packet_pad(Pointer data, int len, int new_len, int nb_streams);
    /**
     * Pads a given Opus multi-stream packet to a larger size (possibly changing the TOC sequence).<br>
     * @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the<br>
     *                                                   packet to pad.<br>
     * @param len <tt>opus_int32</tt>: The size of the packet.<br>
     *                                 This must be at least 1.<br>
     * @param new_len <tt>opus_int32</tt>: The desired size of the packet after padding.<br>
     *                                 This must be at least 1.<br>
     * @param nb_streams <tt>opus_int32</tt>: The number of streams (not channels) in the packet.<br>
     *                                 This must be at least as large as len.<br>
     * @returns an error code<br>
     * @retval #OPUS_OK \a on success.<br>
     * @retval #OPUS_BAD_ARG \a len was less than 1.<br>
     * @retval #OPUS_INVALID_PACKET \a data did not contain a valid Opus packet.<br>
     * Original signature : <code>int opus_multistream_packet_pad(unsigned char*, opus_int32, opus_int32, int)</code><br>
     * <i>native declaration : line 1874</i>
     */
    int opus_multistream_packet_pad(ByteBuffer data, int len, int new_len, int nb_streams);
    /**
     * Remove all padding from a given Opus multi-stream packet and rewrite the TOC sequence to<br>
     * minimize space usage.<br>
     * @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the<br>
     *                                                   packet to strip.<br>
     * @param len <tt>opus_int32</tt>: The size of the packet.<br>
     *                                 This must be at least 1.<br>
     * @param nb_streams <tt>opus_int32</tt>: The number of streams (not channels) in the packet.<br>
     *                                 This must be at least 1.<br>
     * @returns The new size of the output packet on success, or an error code<br>
     *          on failure.<br>
     * @retval #OPUS_BAD_ARG \a len was less than 1 or new_len was less than len.<br>
     * @retval #OPUS_INVALID_PACKET \a data did not contain a valid Opus packet.<br>
     * Original signature : <code>opus_int32 opus_multistream_packet_unpad(unsigned char*, opus_int32, int)</code><br>
     * <i>native declaration : line 1889</i><br>
     * @deprecated use the safer methods {@link #opus_multistream_packet_unpad(java.nio.ByteBuffer, int, int)} and {@link #opus_multistream_packet_unpad(com.sun.jna.Pointer, int, int)} instead
     */
    @Deprecated
    int opus_multistream_packet_unpad(Pointer data, int len, int nb_streams);
    /**
     * Remove all padding from a given Opus multi-stream packet and rewrite the TOC sequence to<br>
     * minimize space usage.<br>
     * @param[in,out] data <tt>const unsigned char*</tt>: The buffer containing the<br>
     *                                                   packet to strip.<br>
     * @param len <tt>opus_int32</tt>: The size of the packet.<br>
     *                                 This must be at least 1.<br>
     * @param nb_streams <tt>opus_int32</tt>: The number of streams (not channels) in the packet.<br>
     *                                 This must be at least 1.<br>
     * @returns The new size of the output packet on success, or an error code<br>
     *          on failure.<br>
     * @retval #OPUS_BAD_ARG \a len was less than 1 or new_len was less than len.<br>
     * @retval #OPUS_INVALID_PACKET \a data did not contain a valid Opus packet.<br>
     * Original signature : <code>opus_int32 opus_multistream_packet_unpad(unsigned char*, opus_int32, int)</code><br>
     * <i>native declaration : line 1889</i>
     */
    int opus_multistream_packet_unpad(ByteBuffer data, int len, int nb_streams);
    public static class OpusRepacketizer extends PointerType {
        public OpusRepacketizer(Pointer address) {
            super(address);
        }
        public OpusRepacketizer() {
            super();
        }
    };
    public static class OpusEncoder extends PointerType {
        public OpusEncoder(Pointer address) {
            super(address);
        }
        public OpusEncoder() {
            super();
        }
    };
    public static class OpusDecoder extends PointerType {
        public OpusDecoder(Pointer address) {
            super(address);
        }
        public OpusDecoder() {
            super();
        }
    };
}